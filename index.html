<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script
        src="https://code.jquery.com/jquery-3.1.1.min.js"
        integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
        crossorigin="anonymous"></script>

    <!--<script src='https://api.mapbox.com/mapbox-gl-js/v0.29.0/mapbox-gl.js'></script>-->
    <link href='https://api.mapbox.com/mapbox-gl-js/v0.29.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://npmcdn.com/@turf/turf@3.5.1/turf.min.js'></script>

    <!-- THIS IS A CUSTOM BUILD OF MAPBOX-GL, USING THE CANVAS_TYPE BRANCH -->
    <script src='mapbox-gl.js'></script>

    <style>
        html, body {
            width: 100%;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id='map'></div>

<script>

    mapboxgl.accessToken = 'pk.eyJ1IjoiZGRicmFkc2hhdyIsImEiOiJQemtJRXhvIn0.zJBiAX860916-nQlwX839w';

    this.map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v9',
        center: [-86.7867764795425,33.3664210488093],
        zoom: 21
    });
    
    //TEST 1:
    //Uses custom build of mapbox-gl that implements canvas source type
    //this.map.on('load', renderCanvasSource.bind(this));

    //TEST 2:
    //Render hexgrid using turf.  WARNING, test with small browser window!
    //this.map.on('load', renderTurf.bind(this));

    //TEST 3:
    //Renders local data as geojson
    this.map.on('load', renderLocalData.bind(this));

    //TEST 4:
    //Renders data to simple canvas
    //this.map.on('load', renderSimpleCanvas.bind(this));

    //TEST 5:
    //Simple API test
    //this.map.on('load', renderAPIData.bind(this));

    function renderAPIData() {
        $.ajax({
            dataType: "json",
            url: 'apidata.geojson',
            success: dataHandler.bind(this)
        });
    }

    function dataHandler(resp) {
        let fc = {"type":"FeatureCollection", "features":[]};
        for(id in resp.hexGridData) {
            let bin = resp.hexGridData[id];
            let f = {"type":"Feature", "geometry":bin.geometry, "properties":{"tv":bin.data[0].data[0]}};
            fc.features.push(f);
        }

        this.map.addSource('hexbins', {
            type: 'geojson',
            data: fc
        });

        this.map.addLayer({
            'id': 'hex',
            'type': 'fill',
            'source': 'hexbins',
            'paint': {
                'fill-outline-color': '#fff',
                'fill-opacity': .2,
                'fill-color': {
                    property: 'tv',
                    stops: [
                        [50, 'rgba(0, 246, 255, 1)'],
                        [100, 'rgba(0, 255, 168, 1)'],
                        [150, 'rgba(0, 255, 54, 1)'],
                        [200, 'rgba(72, 255, 0, 1)'],
                        [250, 'rgba(204, 255, 0, 1)'],
                        [300, 'rgba(255, 210, 0, 1)'],
                        [350, 'rgba(255, 18, 0, 1)']
                    ]
                }
            }
        });
    }


    function renderSimpleCanvas() {
        this.showCanvas = true;
        let container = map.getCanvasContainer();
        let canvas = map.getCanvas();
        let width = container.width;
        let height = container.height

        this.overlay = document.createElement("canvas"); 
        this.overlay.setAttribute('id', 'fabric');
        this.overlay.style.cssText = "position:absolute; top:0px; left:0px; z-index:10;";
        this.ctx = this.overlay.getContext("2d");
        overlay.width = canvas.width;
        overlay.height = canvas.height

        container.appendChild(overlay); 

        // re-render our visualization whenever the view changes
        this.map.on("movestart", function() {
            this.overlay.style.display = "none";
        }.bind(this));
        this.map.on("moveend", function() {
            render()
        });

        // render our initial visualization
        render();
    }

    function renderCanvasSource() {
        this.showCanvas = false;
        let container = map.getCanvasContainer();
        let canvas = map.getCanvas();
        let width = container.width;
        let height = container.height

        this.overlay = document.createElement("canvas"); 
        this.overlay.setAttribute('id', 'fabric');
        this.overlay.style.cssText = "position:absolute; top:0px; left:0px; z-index:10; display:none;";
        this.ctx = this.overlay.getContext("2d");
        overlay.width = canvas.width;
        overlay.height = canvas.height

        container.appendChild(overlay); 

        let bounds = this.map.getBounds();
        let bbox = [
            [bounds._sw.lng, bounds._ne.lat],
            [bounds._ne.lng, bounds._ne.lat],
            [bounds._ne.lng, bounds._sw.lat],
            [bounds._sw.lng, bounds._sw.lat]
        ];

        this.map.addSource('canvas', {
            "type": 'canvas',
            "canvas": 'fabric',
            "coordinates": bbox,
            "dimensions": [0, 0, overlay.width, overlay.height]
        });

        this.map.addLayer({
            'id': 'hex',
            'type': 'raster',
            'source': 'canvas',
            'paint': {'raster-opacity': .2}
        });

        // render our initial visualization
        render();
    }

    function render() {
        let cellArea = 1;
        let cellSideLength = Math.sqrt(cellArea * 2 / (3 * Math.sqrt(3)));   
        let layout = Layout(LAYOUT_FLAT, Point(5,5), Point(0,0));
        let w = Math.floor(this.overlay.width / 5); 
        let h = Math.floor(this.overlay.height / 5);

        /*let bounds = this.map.getBounds();
        let bbox = [
            [bounds._sw.lng, bounds._ne.lat],
            [bounds._ne.lng, bounds._ne.lat],
            [bounds._ne.lng, bounds._sw.lat],
            [bounds._sw.lng, bounds._sw.lat]
        ];
        let canvas = this.map.getSource('canvas');
        canvas.setCoordinates(bbox);*/

        console.log('Hexbin count:', w*h);

        this.ctx.setLineDash([]);
        this.ctx.lineWidth = 1;
        this.ctx.globalAlpha = 0.1;
        this.ctx.save();
        this.ctx.clearRect(0, 0, this.overlay.width, this.overlay.height);

        for(let q = 0; q < w; q++) {
            let q_offset = Math.floor(q / 2);
            for(let r = -q_offset; r < h - q_offset; r++) {
                let corners = polygon_corners(layout, Hex(q, r, -q - r));
                this.ctx.beginPath();
                corners.forEach((coord) => ctx.lineTo(coord.x,coord.y));
                this.ctx.closePath();
                this.ctx.fillStyle = getRandomColor();
                this.ctx.fill();
                this.ctx.stroke();
            }
        }
        this.ctx.restore();

        //Show canvas if not visible
        if(this.showCanvas)
            this.overlay.style.display = "block";
    }

    function Layout(orientation, size, origin) {
        return {orientation: orientation, size: size, origin: origin};
    }

    function Orientation(f0, f1, f2, f3, b0, b1, b2, b3, start_angle) {
        return {f0: f0, f1: f1, f2: f2, f3: f3, b0: b0, b1: b1, b2: b2, b3: b3, start_angle: start_angle};
    }

    function Hex(q, r, s) {
        return {q: q, r: r, s: s};
    }

    function Point(x, y) {
        return {x: x, y: y};
    }

    function polygon_corners(layout, h)
    {
        var corners = [];
        var center = hex_to_pixel(layout, h);
        for (var i = 0; i < 6; i++)
        {
            var offset = hex_corner_offset(layout, i);
            corners.push(Point(center.x + offset.x, center.y + offset.y));
        }
        corners.push(Point(corners[0].x, corners[0].y));
        return corners;
    }

    function hex_to_pixel(layout, h)
    {
        var M = layout.orientation;
        var size = layout.size;
        var origin = layout.origin;
        var x = (M.f0 * h.q + M.f1 * h.r) * size.x;
        var y = (M.f2 * h.q + M.f3 * h.r) * size.y;
        return Point(x + origin.x, y + origin.y);
    }

    function hex_corner_offset(layout, corner)
    {
        var M = layout.orientation;
        var size = layout.size;
        var angle = 2.0 * Math.PI * (M.start_angle - corner) / 6;
        return Point(size.x * Math.cos(angle), size.y * Math.sin(angle));
    }

    const LAYOUT_FLAT = Orientation(3.0 / 2.0, 0.0, Math.sqrt(3.0) / 2.0, Math.sqrt(3.0), 2.0 / 3.0, 0.0, -1.0 / 3.0, Math.sqrt(3.0) / 3.0, 0.0);

    function renderTurf() {
        let bounds = map.getBounds();
        let bbox = [bounds._ne.lng, bounds._ne.lat, bounds._sw.lng, bounds._sw.lat];
        let cellSize = 1;
        let units = 'meters';

        //Generate hexgrid
        let hexgrid = turf.hexGrid(bbox, cellSize, units);

        this.map.addSource('hexbins', {
            type: 'geojson',
            data: hexgrid
        });

        this.map.addLayer({
            'id': 'hex',
            'type': 'fill',
            'source': 'hexbins',
            'paint': {
                'fill-outline-color': '#333',
                'fill-color': 'rgba(0,0,0,0)'
            }
        });
    }

    function renderLocalData() {
        this.map.addSource('hexbins', {
            type: 'geojson',
            data: './hexgrid.geojson'
        });

        this.map.addLayer({
            'id': 'hex',
            'type': 'fill',
            'source': 'hexbins',
            'paint': {
                'fill-opacity': {
                    property: 's',
                    stops: [
                        [0, 0],
                        [1316500, .1],
                        [1316550, .3],
                        [1316600, 0],
                        [1316650, .9],
                        [1316700, 1],
                        [1316750, 1]
                    ]
                },
                'fill-color': {
                    property: 'r',
                    stops: [
                        [0, '#5d9edf'],
                        [8735850, '#EED322'],
                        [8735900, '#69df5d'],
                        [8735950, '#b9ff4a'],
                        [8736000, '#ffc14a'],
                        [8736050, '#ff7d4a'],
                        [8736100, '#ff4a4a']
                    ]
                },
            }
        });

        setInterval(function(e){
            this.map.setPaintProperty('hex', 'fill-color', getRandomColor());
        }.bind(this), 2000);
    }

    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
</script>
</body>
</html>